<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">
    <title>LTZ-LitecoinZ-Designed-for-the-Future</title>
    <meta property="og:type" content="website">
    <meta name="twitter:description" content="LitecoinZ ( LTZ ) is the Decentralized  cryptocurrency for your need to choose.">
    <meta name="description" content="LitecoinZ ( LTZ ) is the Decentralized  cryptocurrency for your need to choose.">
    <meta name="twitter:title" content="LTZ-LitecoinZ-Designed for the Future">
    <meta name="twitter:card" content="summary_large_image">
    <meta property="og:image" content="../assets/img/LitecoinZLogoFacebook.svg">
    <meta name="twitter:image" content="../assets/img/LitecoinZLogoFacebook.svg">
    <meta property="og:description" content="LitecoinZ ( LTZ ) is the Decentralized  cryptocurrency for your need to choose.">
    <meta name="theme-color" content="#35153a">
    <link rel="icon" type="image/svg+xml" sizes="467x465" href="../assets/img/logos/iconLTZ.svg">
    <link rel="icon" type="image/svg+xml" sizes="467x465" href="../assets/img/logos/iconLTZ.svg">
    <link rel="icon" type="image/svg+xml" sizes="467x465" href="../assets/img/logos/iconLTZ.svg">
    <link rel="icon" type="image/svg+xml" sizes="467x465" href="../assets/img/logos/iconLTZ.svg">
    <link rel="icon" type="image/svg+xml" sizes="467x465" href="../assets/img/logos/iconLTZ.svg">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/css/bootstrap.min.css">
    <link rel="manifest" href="../manifest.json">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.1/css/all.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/ionicons/2.0.1/css/ionicons.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Bitter:400,700">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Finger+Paint">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/aos/2.1.1/aos.css">
    <link rel="stylesheet" href="../assets/css/styles.min.css">
</head>

<body>
    <div style="color: none;">
        <div class="header-dark" style="background-image: url(&quot;none&quot;);height: auto;padding-bottom: 0px;color: none;background-color: none;">
            <nav class="navbar navbar-dark navbar-expand-md navigation-clean-search" style="background-color: #2a2a2a;">
                <div class="container"><a class="navbar-brand" href="../ltzcore.html"><img style="width: 148px;margin-left: 35px;" src="../assets/img/logos/ltzcorelogo.png"></a><button data-toggle="collapse" class="navbar-toggler" data-target="#navcol-1"><span class="sr-only">Toggle navigation</span><span class="navbar-toggler-icon"></span></button>
                    <div
                        class="collapse navbar-collapse" id="navcol-1">
                        <ul class="nav navbar-nav">
                            <li class="nav-item" role="presentation"><a class="nav-link text-right" href="../index.html"><strong>LitecoinZ</strong></a></li>
                            <li class="nav-item" role="presentation"><a class="nav-link text-right" href="https://github.com/LitecoinZ-Community/ltzcore"><strong>Github</strong></a></li>
                            <li class="nav-item" role="presentation"><a class="nav-link text-right" href="#"><strong>Guides</strong></a></li>
                            <li class="nav-item" role="presentation"><a class="nav-link text-right" href="https://github.com/LitecoinZ-Community/ltzcore/tree/master/packages"><strong>Doc</strong></a></li>
                        </ul>
                </div>
        </div>
        </nav>
    </div>
    </div>
    <div style="margin-top: 90px;">
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-xl-3">
                    <h1>Guides</h1>
                    <ul class="nav flex-column" style="padding-right: 43px;">
                        <li class="nav-item"><a class="nav-link active" href="fullnode.html"><strong>Running a Full Node</strong><br></a></li>
                        <li class="nav-item"><a class="nav-link" style="color: #2a2a2a;" href="ltzstandalone.html"><strong>Run LTZ Standalone</strong><br></a></li>
                        <li class="nav-item"><a class="nav-link" style="color: #2a2a2a;" href="ltzdeamon.html"><strong>LTZ as Deamon</strong><br></a></li>
                        <li class="nav-item"><a class="nav-link" style="color: #2a2a2a;" href="walletservice.html"><strong>Wallet-Service</strong><br></a></li>
                        <li class="nav-item"><a class="nav-link" style="color: #2a2a2a;" href="browser.html"><strong>Browser Builds</strong><br></a></li>
                    </ul>
                    <h1><span style="text-decoration: underline;">Tutorials</span></h1>
                    <ul class="nav flex-column" style="padding-right: 43px;">
                        <li class="nav-item"><a class="nav-link active" href="servicedev.html"><strong>Service Development</strong><br></a></li>
                        <li class="nav-item"><a class="nav-link" style="color: #2a2a2a;" href="movealram.html"><strong>Movemnet Alarm</strong><br></a></li>
                        <li class="nav-item"><a class="nav-link" style="color: #2a2a2a;" href="lemonade.html"><strong>Lemonade Stand</strong><br></a></li>
                        <li class="nav-item"><a class="nav-link border rounded" style="color: #2a2a2a;background-color: #ffc033;" href="proof.html"><strong>Proof it. Timestamp</strong><br></a></li>
                    </ul>
                </div>
                <div class="col-md-6 col-xl-8 text-break">
                    <h1 style="color: #2a2a2a;"><strong>Proof it, i made this</strong><br></h1>
                    <p style="color: #2a2a2a;font-weight: normal;"><br>In this tutorial, we will build a desktop app that timestamps original files into the blockchain by including their unique hashes as part of the [<strong>OP_RETURN</strong>](http://bitcoin.stackexchange.com/questions/29554/explanation-of-what-an-op-return-transaction-looks-like)
                        data of litecoinz transactions. The timestamps will serve as immutable proof that the files existed at a certain point in time, which can be used to demonstrate ownership of original content. You can [<a href="https://github.com/bitpay/i-made-this"><strong>view the completed project files on GitHub</strong></a>]
                        as reference.<br><br><br><br><br><br><br><br><br><br><strong>How it works</strong><br><br>1. The user uploads a file via the desktop app.<br><br>2. The app hashes the file and asks ltzcore node whether the file has already been
                        timestamped in the blockchain.<br><br>3. If the file has not yet been timestamped, the app generates a new LTZaddress and displays that address to the user in the form of a QR code, prompting the user to send a small amount of
                        LTZ to that address.<br><br>4. Once the user's LTZ arrives at the address, your ltzcore node utilizes the received litecoinz to broadcast a new transaction with the file hash included, serving as a permanent timestamp in the blockchain.<br><br><br><br><strong>What we will use</strong><br><br><br><br>1.
                        A [<a href="https://github.com/LitecoinZ-Community/ltzcore"><strong>ltzcore</strong></a>] node to communicate with the blockchain<br><br>2. A custom ltzcore service to extend your ltzcore node so that it can timestamp files<br><br>3.
                        [<strong>Electron</strong>](http://electron.atom.io) and [<strong>AngularJS</strong>](https://angularjs.org/) to serve as the Desktop UI to communicate with your ltzcore server. (The details of Electron and AngularJS will not be
                        covered as part of this tutorial.)<br><br><br><br><br><br><strong>Starting your project</strong><br><br><br><br>Create a new directory for your project:<br><br></p>
                    <p class="border rounded code" style="color: #eff1f4;background-color: #2a2a2a;padding-left: 15px;padding-right: 15px;font-weight: normal;"><br>mkdir i-made-this<br><br>cd i-made-this<br><br></p>
                    <p style="color: #2a2a2a;font-weight: normal;"><br><strong>Setting up your ltzcore node</strong><br><br>To set up your ltzcore node, [<a href="fullnode.html"><strong>follow the instructions in this guide</strong></a>]. Be sure to configure your ltzcore node to run on [<strong>testnet</strong>]
                        to avoid spending real litecoinzs during development. Also, ensure you are running Node v0.12 or v4.2 LTS.<br><br><br><br>Start your new ltzcore node from within the newly created `<strong>mynode</strong>` directory (the start
                        command must always be executed from within the `<strong>mynode</strong>` directory):<br><br></p>
                    <p class="border rounded code" style="color: #eff1f4;background-color: #2a2a2a;padding-left: 15px;padding-right: 15px;font-weight: normal;"><br>cd mynode<br><br>ltzcored<br><br></p>
                    <p style="color: #2a2a2a;font-weight: normal;"><br>You should now see your ltzcore node begin to download the testnet blockchain (this can take up to 1 hour):<br><br></p>
                    <p class="text-nowrap border rounded code" style="overflow-x: scroll;color: #eff1f4;background-color: #2a2a2a;padding-left: 15px;padding-right: 15px;font-weight: normal;"><br>[2015-10-21T22:53:25.974Z] info: Starting litecoinzd<br><br>[2015-10-21T22:53:27.991Z] info: litecoinz Daemon Ready<br><br>[2015-10-21T22:53:27.992Z] info: Starting db<br><br>[2015-10-21T22:53:28.004Z] info: litecoinz Database
                        Ready<br><br>[2015-10-21T22:53:28.005Z] info: Starting address<br><br>[2015-10-21T22:53:28.005Z] info: Starting web<br><br>[2015-10-21T22:53:28.040Z] info: ltzcore Node ready<br><br>[2015-10-21T22:53:29.994Z] info: litecoinz Height:
                        16 Percentage: 0.000008310586963489186<br><br>[2015-10-21T22:53:30.999Z] info: litecoinz Height: 64 Percentage: 0.00003177577309543267<br><br>[2015-10-21T22:53:32.002Z] info: litecoinz Height: 112 Percentage: 0.000055240951041923836<br><br></p>
                    <p
                        style="color: #2a2a2a;font-weight: normal;"><br><strong>Extending your ltzcore node with a custom service</strong><br><br><br><br>To create your custom ltzcore timestamping service, create a new `<strong>stampingservice</strong>` directory in your project root:<br><br></p>
                        <p
                            class="border rounded code" style="color: #eff1f4;background-color: #2a2a2a;padding-left: 15px;padding-right: 15px;font-weight: normal;"><br>cd ~/i-made-this<br><br>mkdir stampingservice<br><br>cd stampingservice<br><br>nano index.js<br><br></p>
                            <p style="color: #2a2a2a;font-weight: normal;"><br>We will need several Node.js modules:<br><br>- <strong>async </strong>- For asynchronous workflows<br><br>- <strong>levelup </strong>- Interface for storing data<br><br>- <strong>leveldown </strong>- Bindings to LevelDB<br><br>-
                                <strong>mkdirp </strong>- Creating directories<br><br>- <strong>ltzcore-lib</strong> - For working with litecoinz data<br><br><br><br>Install the dependencies to your `<strong>stampingservice</strong>` with:<br><br></p>
                            <p
                                class="border rounded code" style="color: #eff1f4;background-color: #2a2a2a;padding-left: 15px;padding-right: 15px;font-weight: normal;"><br>npm install async levelup leveldown mkdirp ltzcore-lib --save<br><br></p>
                                <p style="color: #2a2a2a;font-weight: normal;"><br>Place the following boilerplate code into `<strong>index.js</strong>`:<br><br></p>
                                <p class="text-nowrap border rounded code" style="overflow-x: scroll;color: #eff1f4;background-color: #2a2a2a;padding-left: 15px;padding-right: 15px;font-weight: normal;"><br>var util = require('util');<br><br>var EventEmitter = require('events').EventEmitter;<br><br>var async = require('async');<br><br>var levelup = require('levelup');<br><br>var leveldown = require('leveldown');<br><br>var
                                    mkdirp = require('mkdirp');<br><br>var ltzcore = require('ltzcore-lib');<br><br>var BufferUtil = ltzcore.util.buffer;<br><br>var Networks = ltzcore.Networks;<br><br>var Block = ltzcore.Block;<br><br>var $ = ltzcore.util.preconditions;<br><br><br><br>function
                                    enableCors(response) {<br><br>&nbsp;// A convenience function to ensure<br><br>&nbsp;// the response object supports cross-origin requests<br><br>&nbsp;response.set('Access-Control-Allow-Origin','*');<br><br>&nbsp;response.set('Access-Control-Allow-Methods','POST,
                                    GET, OPTIONS, PUT');<br><br>&nbsp;response.set('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');<br><br>}<br><br><br><br>function StampingService(options) {<br><br>&nbsp;EventEmitter.call(this);<br><br>&nbsp;this.node
                                    = options.node;<br><br><br><br>&nbsp;$.checkState(this.node.network, 'Node is expected to have a "network" property');<br><br>&nbsp;this.network = this.node.network;<br><br><br><br>&nbsp;this.log = this.node.log;<br><br>}<br><br>util.inherits(StampingService,
                                    EventEmitter);<br><br><br><br>StampingService.dependencies = ['litecoinzd'];<br><br><br><br>StampingService.prototype.getAPIMethods = function(){<br><br>&nbsp;return [];<br><br>}<br><br><br><br>StampingService.prototype.getPublishEvents
                                    = function(){<br><br>&nbsp;return [];<br><br>}<br><br><br><br>StampingService.prototype.getRoutePrefix = function() {<br><br>&nbsp;return 'stampingservice';<br><br>}<br><br><br><br>StampingService.prototype.start =
                                    function(callback) {<br><br>&nbsp;setImmediate(callback);<br><br>}<br><br><br><br>StampingService.prototype.stop = function(callback) {<br><br>&nbsp;setImmediate(callback);<br><br>}<br><br><br><br>module.exports = StampingService;<br><br></p>
                                <p
                                    style="color: #2a2a2a;font-weight: normal;"><br><strong>&nbsp;Checking for previous timestamps</strong><br><br><br><br>To check whether a file has been previously timestamped in the blockchain we need to add several methods to `<strong>index.js</strong>` to keep
                                    our database is sync with the litecoinz block chain. Because there can be block reorganizations where the chain can go into a different direction, we will need to make sure that all our operations are reversable. The
                                    effects of each block will commited to our database atomically. We can then connect and disconnect blocks into the chain.<br><br><br><br><strong>We will need to be able to:</strong><br><br>- Setup a LevelDB database<br><br>-
                                    Record our current position in the chain<br><br>- Parse a block for the data of interest, in this case OP_RETURN data<br><br>- Connect a new block to the chain<br><br>- Disconnect the current tip from the chain<br><br>-
                                    Walk the chain, and verify it is continuous<br><br>- Lookup the data that we've stored<br><br><br><br><br><br>To setup the LevelDB database, we will first establish the path of the database, with a helper method:<br><br></p>
                                    <p
                                        class="text-nowrap border rounded code" style="overflow-x: scroll;color: #eff1f4;background-color: #2a2a2a;padding-left: 15px;padding-right: 15px;font-weight: normal;"><br>StampingService.prototype._setDataPath = function() {<br><br>&nbsp;$.checkState(this.node.services.litecoinzd.spawn.datadir, 'litecoinzd is expected to have a "spawn.datadir" property');<br><br>&nbsp;var datadir
                                        = this.node.services.litecoinzd.spawn.datadir;<br><br>&nbsp;if (this.node.network === Networks.livenet) {<br><br>&nbsp;&nbsp;this.dataPath = datadir + '/ltzcore-stamps.db';<br><br>&nbsp;} else if (this.node.network
                                        === Networks.testnet) {<br><br>&nbsp;&nbsp;if (this.node.network.regtestEnabled) {<br><br>&nbsp;&nbsp;&nbsp;this.dataPath = datadir + '/regtest/ltzcore-stamps.db';<br><br>&nbsp;&nbsp;} else {<br><br>&nbsp;&nbsp;&nbsp;this.dataPath
                                        = datadir + '/testnet3/ltzcore-stamps.db';<br><br>&nbsp;&nbsp;}<br><br>&nbsp;} else {<br><br>&nbsp;&nbsp;throw new Error('Unknown network: ' + this.network);<br><br>&nbsp;}<br><br>};<br><br></p>
                                        <p style="color: #2a2a2a;font-weight: normal;"><br>And then call this function at construction and setup levelup, and other variables needed ( javascript ):<br><br></p>
                                        <p class="border rounded code" style="color: #eff1f4;background-color: #2a2a2a;padding-left: 15px;padding-right: 15px;font-weight: normal;"><br>function StampingService(options) {<br><br>&nbsp;//...<br><br>&nbsp;this._setDataPath();<br><br>&nbsp;this.levelupStore = leveldown;<br><br>&nbsp;if (options.store) {<br><br>&nbsp;&nbsp;this.levelupStore = options.store;<br><br>&nbsp;}<br><br>&nbsp;//...<br><br>}<br><br>util.inherits(StampingService,
                                            EventEmitter);<br><br><br></p>
                                        <p style="color: #2a2a2a;font-weight: normal;"><br>And then in our start function, and some additional logic ( javascript ):<br><br></p>
                                        <p class="border rounded code" style="color: #eff1f4;background-color: #2a2a2a;padding-left: 15px;padding-right: 15px;font-weight: normal;"><br>StampingService.prototype.start = function(callback) {<br><br>&nbsp;if (!fs.existsSync(this.dataPath)) {<br><br>&nbsp;&nbsp;mkdirp.sync(this.dataPath);<br><br>&nbsp;}<br><br><br><br>&nbsp;this.store = levelup(this.dataPath,
                                            { db: this.levelupStore });<br><br>};<br><br><br></p>
                                        <p style="color: #2a2a2a;font-weight: normal;"><br>And some code to close the database on shutdown ( &nbsp;javascript ):<br><br><br></p>
                                        <p class="border rounded code" style="color: #eff1f4;background-color: #2a2a2a;padding-left: 15px;padding-right: 15px;font-weight: normal;"><br>StampingService.prototype.stop = function(callback) {<br><br>&nbsp;&nbsp;self.store.close(callback);<br><br>};<br><br></p>
                                        <p style="color: #2a2a2a;font-weight: normal;"><br>We should now be able to open and close the levelup database to store our data.<br><br><br><br>Next we will go into how we can keep our database is sync with the blockchain. Let's start by<br><br>working on
                                            the method that will actually parse the block and store and remove the data. The blockHandler<br><br>method is included below. Add this method to `<strong>index.js</strong>`.<br><br></p>
                                        <p class="text-nowrap border rounded code"
                                            style="overflow-x: scroll;color: #eff1f4;background-color: #2a2a2a;padding-left: 15px;padding-right: 15px;font-weight: normal;"><br>StampingService.prototype.blockHandler = function(block, add, callback) {<br><br>&nbsp;var self = this;<br><br><br><br>&nbsp;var operations = [];<br><br><br><br>&nbsp;// Update tip<br><br>&nbsp;var tipHash =
                                            add ? new Buffer(block.hash, 'hex') : BufferUtil.reverse(block.header.prevHash);<br><br>&nbsp;operations.push({<br><br>&nbsp;&nbsp;type: 'put',<br><br>&nbsp;&nbsp;key: StampingService.PREFIX_TIP,<br><br>&nbsp;&nbsp;value:
                                            tipHash<br><br>&nbsp;});<br><br><br><br>&nbsp;var txs = block.transactions;<br><br>&nbsp;var height = block.__height;<br><br><br><br>&nbsp;// Loop through every transaction in the block<br><br>&nbsp;var transactionLength
                                            = txs.length;<br><br>&nbsp;for (var i = 0; i &lt; transactionLength; i++) {<br><br>&nbsp;&nbsp;var tx = txs[i];<br><br>&nbsp;&nbsp;var txid = tx.id;<br><br>&nbsp;&nbsp;var outputs = tx.outputs;<br><br>&nbsp;&nbsp;var
                                            outputScriptHashes = {};<br><br>&nbsp;&nbsp;var outputLength = outputs.length;<br><br><br><br>&nbsp;&nbsp;// Loop through every output in the transaction<br><br>&nbsp;&nbsp;for (var outputIndex = 0; outputIndex
                                            &lt; outputLength; outputIndex++) {<br><br>&nbsp;&nbsp;&nbsp;var output = outputs[outputIndex];<br><br>&nbsp;&nbsp;&nbsp;var script = output.script;<br><br><br><br>&nbsp;&nbsp;&nbsp;if(!script || !script.isDataOut())
                                            {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;self.log.debug('Invalid script');<br><br>&nbsp;&nbsp;&nbsp;&nbsp;continue;<br><br>&nbsp;&nbsp;&nbsp;}<br><br><br><br>&nbsp;&nbsp;&nbsp;// If we find outputs with script data,
                                            we need to store the transaction into level db<br><br>&nbsp;&nbsp;&nbsp;var scriptData = script.getData().toString('hex');<br><br>&nbsp;&nbsp;&nbsp;self.log.info('scriptData added to index:', scriptData);<br><br><br><br>&nbsp;&nbsp;&nbsp;//
                                            Prepend a prefix to the key to prevent namespacing collisions<br><br>&nbsp;&nbsp;&nbsp;// Append the block height, txid, and outputIndex for ordering purposes (ensures transactions will be returned<br><br>&nbsp;&nbsp;&nbsp;//
                                            in the order they occured)<br><br>&nbsp;&nbsp;&nbsp;var key = [StampingService.PREFIX, scriptData, height, txid, outputIndex].join('-');<br><br>&nbsp;&nbsp;&nbsp;var value = block.hash;<br><br><br><br>&nbsp;&nbsp;&nbsp;var
                                            action = add ? 'put' : 'del';<br><br>&nbsp;&nbsp;&nbsp;var operation = {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;type: action,<br><br>&nbsp;&nbsp;&nbsp;&nbsp;key: key,<br><br>&nbsp;&nbsp;&nbsp;&nbsp;value: value<br><br>&nbsp;&nbsp;&nbsp;};<br><br><br><br>&nbsp;&nbsp;&nbsp;operations.push(operation);<br><br>&nbsp;&nbsp;}<br><br>&nbsp;}<br><br><br><br>&nbsp;self.log.debug('Updating
                                            the database with operations', operations);<br><br>&nbsp;self.store.batch(operations, callback);<br><br>}<br><br></p>
                                        <p style="color: #2a2a2a;font-weight: normal;"><br>Now we will add two methods that will call `<strong>blockHandler</strong>` ( javascript ):<br><br></p>
                                        <p class="border rounded code" style="/*overflow-x: scroll;*/color: #eff1f4;background-color: #2a2a2a;padding-left: 15px;padding-right: 15px;font-weight: normal;"><br>StampingService.prototype.connectBlock = function(block, callback) {<br><br>&nbsp;this.log.info('adding block', block.hash);<br><br>&nbsp;this.blockHandler(block, true, callback);<br><br>};<br><br><br><br>StampingService.prototype.disconnectBlock
                                            = function(block, callback) {<br><br>&nbsp;this.log.info('disconnecting block', block.hash);<br><br>&nbsp;this.blockHandler(block, false, callback);<br><br>};<br><br><br></p>
                                        <p style="color: #2a2a2a;font-weight: normal;"><br>Now that we can add and remove blocks from the database, we need to be able to<br><br>get the current tip of the chain, and then connect and remove blocks from the chain.<br><br><br><br>First lets get the code
                                            to load and remove the tip of the chain.<br><br><br><br><strong>Note</strong>: Ideally to ensure that we always have access to the block data that we have<br><br>written, we would also keep a record of the latest
                                            blocks locally (<strong>without relying on litecoinzd</strong>).<br><br>Here we attempt several times and then give up.<br><br><br><br></p>
                                        <p class="text-nowrap border rounded code" style="overflow-x: scroll;color: #eff1f4;background-color: #2a2a2a;padding-left: 15px;padding-right: 15px;font-weight: normal;"><br>StampingService.prototype.loadTip = function(callback) {<br><br>&nbsp;var self = this;<br><br><br><br>&nbsp;var options = {<br><br>&nbsp;&nbsp;keyEncoding: 'binary',<br><br>&nbsp;&nbsp;valueEncoding: 'binary'<br><br>&nbsp;};<br><br><br><br>&nbsp;self.store.get(StampingService.PREFIX_TIP,
                                            options, function(err, tipData) {<br><br>&nbsp;&nbsp;if(err &amp;&amp; err instanceof levelup.errors.NotFoundError) {<br><br>&nbsp;&nbsp;&nbsp;self.tip = self.genesis;<br><br>&nbsp;&nbsp;&nbsp;self.tip.__height
                                            = 0;<br><br>&nbsp;&nbsp;&nbsp;self.connectBlock(self.genesis, function(err) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if(err) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return callback(err);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;self.emit('addblock',
                                            self.genesis);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;callback();<br><br>&nbsp;&nbsp;&nbsp;});<br><br>&nbsp;&nbsp;&nbsp;return;<br><br>&nbsp;&nbsp;} else if(err) {<br><br>&nbsp;&nbsp;&nbsp;return callback(err);<br><br>&nbsp;&nbsp;}<br><br><br><br>&nbsp;&nbsp;var
                                            hash = tipData.toString('hex');<br><br><br><br>&nbsp;&nbsp;var times = 0;<br><br>&nbsp;&nbsp;async.retry({times: 3, interval: self.retryInterval}, function(done) {<br><br>&nbsp;&nbsp;&nbsp;self.node.getBlock(hash,
                                            function(err, tip) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if(err) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;times++;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.log.warn('litecoinzd does not have our tip (' + hash + ').
                                            litecoinzd may have crashed and needs to catch up.');<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(times &lt; 3) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.log.warn('Retrying in ' + (self.retryInterval / 1000)
                                            + ' seconds.');<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return done(err);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;done(null, tip);<br><br>&nbsp;&nbsp;&nbsp;});<br><br>&nbsp;&nbsp;},
                                            function(err, tip) {<br><br>&nbsp;&nbsp;&nbsp;if(err) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;self.log.warn('Giving up after 3 tries. Please report this bug to https://github.com/bitpay/ltzcore-node/issues');<br><br>&nbsp;&nbsp;&nbsp;&nbsp;self.log.warn('Please
                                            reindex your database.');<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return callback(err);<br><br>&nbsp;&nbsp;&nbsp;}<br><br><br><br>&nbsp;&nbsp;&nbsp;self.tip = tip;<br><br>&nbsp;&nbsp;&nbsp;self.node.getBlockHeader(self.tip.hash,
                                            function(err, blockHeader) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if (err) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return callback(err);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if(!blockHeader)
                                            {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return callback(new Error('Could not get height for tip.'));<br><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;self.tip.__height = blockHeader.height;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;callback();<br><br>&nbsp;&nbsp;&nbsp;});<br><br><br><br>&nbsp;&nbsp;});<br><br>&nbsp;});<br><br>};<br><br></p>
                                        <p
                                            style="color: #2a2a2a;font-weight: normal;"><br>This method then needs to be called when we start:<br><br><br></p>
                                            <p class="border rounded code" style="color: #eff1f4;background-color: #2a2a2a;padding-left: 15px;padding-right: 15px;font-weight: normal;"><br>StampingService.prototype.start = function(callback) {<br><br>&nbsp;// ...<br><br>&nbsp;self.loadTip(function(err) {<br><br>&nbsp;&nbsp;if (err) {<br><br>&nbsp;&nbsp;&nbsp;return callback(err);<br><br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;self.emit('ready');<br><br>&nbsp;&nbsp;callback();<br><br>&nbsp;});<br><br>};<br><br></p>
                                            <p
                                                style="color: #2a2a2a;font-weight: normal;"><br>We now also need to be able to remove the tip:<br><br><br></p>
                                                <p class="border rounded code" style="/*overflow-x: scroll;*/color: #eff1f4;background-color: #2a2a2a;padding-left: 15px;padding-right: 15px;font-weight: normal;"><br>StampingService.prototype.disconnectTip = function(done) {<br><br>&nbsp;var self = this;<br><br><br><br>&nbsp;var tip = self.tip;<br><br><br><br>&nbsp;// TODO: expose prevHash as a string from ltzcore<br><br>&nbsp;var
                                                    prevHash = BufferUtil.reverse(tip.header.prevHash).toString('hex');<br><br><br><br>&nbsp;self.node.getBlock(prevHash, function(err, previousTip) {<br><br>&nbsp;&nbsp;if (err) {<br><br>&nbsp;&nbsp;&nbsp;done(err);<br><br>&nbsp;&nbsp;}<br><br><br><br>&nbsp;&nbsp;//
                                                    Undo the related indexes for this block<br><br>&nbsp;&nbsp;self.disconnectBlock(tip, function(err) {<br><br>&nbsp;&nbsp;&nbsp;if (err) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return done(err);<br><br>&nbsp;&nbsp;&nbsp;}<br><br><br><br>&nbsp;&nbsp;&nbsp;//
                                                    Set the new tip<br><br>&nbsp;&nbsp;&nbsp;previousTip.__height = self.tip.__height - 1;<br><br>&nbsp;&nbsp;&nbsp;self.tip = previousTip;<br><br>&nbsp;&nbsp;&nbsp;self.emit('removeblock', tip);<br><br>&nbsp;&nbsp;&nbsp;done();<br><br>&nbsp;&nbsp;});<br><br>&nbsp;});<br><br>};<br><br></p>
                                                <p
                                                    style="color: #2a2a2a;font-weight: normal;"><br>Next we need a function that will take our current tip and advance the chain and verify that the chain continues. In the case that the chain does not continue, we will remove the current tip, and the
                                                    try to advance the chain again.<br><br><br></p>
                                                    <p class="border rounded code" style="color: #eff1f4;background-color: #2a2a2a;padding-left: 15px;padding-right: 15px;font-weight: normal;"><br>StampingService.prototype.sync = function() {<br><br>&nbsp;var self = this;<br><br><br><br>&nbsp;if (self.litecoinzdSyncing || self.node.stopping || !self.tip) {<br><br>&nbsp;&nbsp;return;<br><br>&nbsp;}<br><br><br><br>&nbsp;self.litecoinzdSyncing
                                                        = true;<br><br><br><br>&nbsp;var height;<br><br><br><br>&nbsp;async.whilst(function() {<br><br>&nbsp;&nbsp;if (self.node.stopping) {<br><br>&nbsp;&nbsp;&nbsp;return false;<br><br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;height
                                                        = self.tip.__height;<br><br>&nbsp;&nbsp;return height &lt; self.node.services.litecoinzd.height;<br><br>&nbsp;}, function(done) {<br><br>&nbsp;&nbsp;self.node.getRawBlock(height + 1, function(err,
                                                        blockBuffer) {<br><br>&nbsp;&nbsp;&nbsp;if (err) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return done(err);<br><br>&nbsp;&nbsp;&nbsp;}<br><br><br><br>&nbsp;&nbsp;&nbsp;var block = Block.fromBuffer(blockBuffer);<br><br><br><br>&nbsp;&nbsp;&nbsp;//
                                                        TODO: expose prevHash as a string from ltzcore<br><br>&nbsp;&nbsp;&nbsp;var prevHash = BufferUtil.reverse(block.header.prevHash).toString('hex');<br><br><br><br>&nbsp;&nbsp;&nbsp;if (prevHash ===
                                                        self.tip.hash) {<br><br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;// This block appends to the current chain tip and we can<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// immediately add it to the chain and create indexes.<br><br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;//
                                                        Populate height<br><br>&nbsp;&nbsp;&nbsp;&nbsp;block.__height = self.tip.__height + 1;<br><br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;// Create indexes<br><br>&nbsp;&nbsp;&nbsp;&nbsp;self.connectBlock(block,
                                                        function(err) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (err) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return done(err);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.tip
                                                        = block;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.log.debug('Chain added block to main chain');<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.emit('addblock', block);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;done();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;});<br><br>&nbsp;&nbsp;&nbsp;}
                                                        else {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// This block doesn't progress the current tip, so we'll attempt<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// to rewind the chain to the common ancestor of the block and<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//
                                                        then we can resume syncing.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;self.log.warn('Reorg detected! Current tip: ' + self.tip.hash);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;self.disconnectTip(function(err) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(err)
                                                        {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return done(err);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.log.warn('Disconnected current tip. New tip is ' +
                                                        self.tip.hash);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;done();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;});<br><br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;});<br><br>&nbsp;}, function(err) {<br><br>&nbsp;&nbsp;if
                                                        (err) {<br><br>&nbsp;&nbsp;&nbsp;Error.captureStackTrace(err);<br><br>&nbsp;&nbsp;&nbsp;return self.node.emit('error', err);<br><br>&nbsp;&nbsp;}<br><br><br><br>&nbsp;&nbsp;if(self.node.stopping)
                                                        {<br><br>&nbsp;&nbsp;&nbsp;self.litecoinzdSyncing = false;<br><br>&nbsp;&nbsp;&nbsp;return;<br><br>&nbsp;&nbsp;}<br><br><br><br>&nbsp;&nbsp;self.node.isSynced(function(err, synced) {<br><br>&nbsp;&nbsp;&nbsp;if
                                                        (err) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;Error.captureStackTrace(err);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return self.node.emit('error', err);<br><br>&nbsp;&nbsp;&nbsp;}<br><br><br><br>&nbsp;&nbsp;&nbsp;if
                                                        (synced) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;self.litecoinzdSyncing = false;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;self.node.emit('synced');<br><br>&nbsp;&nbsp;&nbsp;} else {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;self.litecoinzdSyncing
                                                        = false;<br><br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;});<br><br><br><br>&nbsp;});<br><br><br><br>};<br><br></p>
                                                    <p style="color: #2a2a2a;font-weight: normal;"><br>We now need to call the `<strong>sync</strong>` method when there is a new block and after we have loaded the chain tip from the database. We can do this by adding some code to the `<strong>start</strong>`
                                                        method:<br><br></p>
                                                    <p class="border rounded code" style="color: #eff1f4;background-color: #2a2a2a;padding-left: 15px;padding-right: 15px;font-weight: normal;"><br>StampingService.prototype.start = function(callback) {<br><br>&nbsp;//...<br><br>&nbsp;this.once('ready', function() {<br><br>&nbsp;&nbsp;self.log.info('litecoinz Database Ready');<br><br><br><br>&nbsp;&nbsp;self.node.services.litecoinzd.on('tip',
                                                        function() {<br><br>&nbsp;&nbsp;&nbsp;if(!self.node.stopping) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;self.sync();<br><br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;});<br><br>&nbsp;});<br><br><br><br>&nbsp;self.loadTip(function(err)
                                                        {<br><br>&nbsp;&nbsp;if (err) {<br><br>&nbsp;&nbsp;&nbsp;return callback(err);<br><br>&nbsp;&nbsp;}<br><br><br><br>&nbsp;&nbsp;self.sync();<br><br>&nbsp;&nbsp;self.emit('ready');<br><br>&nbsp;&nbsp;callback();<br><br>&nbsp;});<br><br>&nbsp;//...<br><br>};<br><br></p>
                                                    <p
                                                        style="color: #2a2a2a;font-weight: normal;"><br><br><br>Now that the database will be kept in sync with the blockchain we can add a method to lookup the data stored.<br><br><br><br>The `<strong>lookupHash</strong>` method shown below will be called
                                                        by the client-side code whenever a user uploads a file to<br><br>check whether that file has already been timestamped. This method will query the data that has<br><br>been stored by the blockHandler
                                                        method above.<br><br></p>
                                                        <p class="text-nowrap border rounded code" style="overflow-x: scroll;color: #eff1f4;background-color: #2a2a2a;padding-left: 15px;padding-right: 15px;font-weight: normal;"><br>StampingService.prototype.lookupHash = function(req, res, next) {<br><br>&nbsp;/*<br><br>&nbsp;&nbsp;This method is used to determine whether a file hash has<br><br>&nbsp;&nbsp;already been included
                                                            in the blockchain. We are querying data<br><br>&nbsp;&nbsp;from level db that we previously stored into level db via the blockHanlder.<br><br>&nbsp;*/<br><br>&nbsp;var self = this;<br><br>&nbsp;enableCors(res);<br><br><br><br>&nbsp;var
                                                            hash = req.params.hash; // the hash of the uploaded file<br><br>&nbsp;this.log.info('request for hash:', hash);<br><br>&nbsp;var node = this.node;<br><br><br><br>&nbsp;// Search level db for
                                                            instances of this file hash<br><br>&nbsp;// and put them in objArr<br><br>&nbsp;var stream = self.store.createReadStream({<br><br>&nbsp;&nbsp;gte: [StampingService.PREFIX, hash].join('-'),<br><br>&nbsp;&nbsp;lt:
                                                            [StampingService.PREFIX, hash].join('-') + '~'<br><br>&nbsp;});<br><br><br><br>&nbsp;var objArr = [];<br><br><br><br>&nbsp;stream.on('data', function(data) {<br><br>&nbsp;&nbsp;// Parse data
                                                            as matches are found and push it<br><br>&nbsp;&nbsp;// to the objArr<br><br>&nbsp;&nbsp;data.key = data.key.split('-');<br><br>&nbsp;&nbsp;var obj = {<br><br>&nbsp;&nbsp;&nbsp;hash: data.value,<br><br>&nbsp;&nbsp;&nbsp;height:
                                                            data.key[2],<br><br>&nbsp;&nbsp;&nbsp;txid: data.key[3],<br><br>&nbsp;&nbsp;&nbsp;outputIndex: data.key[4]<br><br>&nbsp;&nbsp;};<br><br>&nbsp;&nbsp;objArr.push(obj);<br><br>&nbsp;});<br><br><br><br>&nbsp;var
                                                            error;<br><br><br><br>&nbsp;stream.on('error', function(streamError) {<br><br>&nbsp;&nbsp;// Handle any errors during the search<br><br>&nbsp;&nbsp;if (streamError) {<br><br>&nbsp;&nbsp;&nbsp;error
                                                            = streamError;<br><br>&nbsp;&nbsp;}<br><br>&nbsp;});<br><br><br><br>&nbsp;stream.on('close', function() {<br><br>&nbsp;&nbsp;if (error) {<br><br>&nbsp;&nbsp;&nbsp;return res.send(500, error.message);<br><br>&nbsp;&nbsp;}
                                                            else if(!objArr.length) {<br><br>&nbsp;&nbsp;&nbsp;return res.sendStatus(404);<br><br>&nbsp;&nbsp;}<br><br><br><br>&nbsp;&nbsp;// For each transaction that included our file hash, get additional<br><br>&nbsp;&nbsp;//
                                                            info from the blockchain about the transaction (such as the timestamp and source address).<br><br>&nbsp;&nbsp;async.each(objArr, function(obj, eachCallback) {<br><br>&nbsp;&nbsp;&nbsp;var txid
                                                            = obj.txid;<br><br>&nbsp;&nbsp;&nbsp;var includeMempool = true;<br><br><br><br>&nbsp;&nbsp;&nbsp;node.log.info('getting details for txid:', txid);<br><br>&nbsp;&nbsp;&nbsp;node.getDetailedTransaction(txid,
                                                            function(err, transaction) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if (err){<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return eachCallback(err);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;var
                                                            address = transaction.inputs[0].address;<br><br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;obj.sourceAddress = address;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;obj.timestamp = transaction.blockTimestamp;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return
                                                            eachCallback();<br><br>&nbsp;&nbsp;&nbsp;});<br><br>&nbsp;&nbsp;}, function doneGrabbingTransactionData(err) {<br><br>&nbsp;&nbsp;&nbsp;if (err){<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return res.send(500,
                                                            err);<br><br>&nbsp;&nbsp;&nbsp;}<br><br><br><br>&nbsp;&nbsp;&nbsp;// Send back matches to the client<br><br>&nbsp;&nbsp;&nbsp;res.send(objArr);<br><br>&nbsp;&nbsp;});<br><br><br><br>&nbsp;});<br><br>}<br><br></p>
                                                        <p
                                                            style="color: #2a2a2a;font-weight: normal;"><br><strong>Monitoring LTZ addresses</strong><br><br><br><br>To determine whether the user has sent LTZ to the address generated by the desktop client, we'll add the following method to `<strong>index.js</strong>`:<br><br></p>
                                                            <p
                                                                class="border rounded code" style="color: #eff1f4;background-color: #2a2a2a;padding-left: 15px;padding-right: 15px;font-weight: normal;"><br>StampingService.prototype.getAddressData = function(req, res, next) {<br><br>&nbsp;/*<br><br>&nbsp;&nbsp;This method is called by the client to determine whether a LTZ address<br><br>&nbsp;&nbsp;has
                                                                recieved funds yet<br><br>&nbsp;*/<br><br>&nbsp;var self = this;<br><br>&nbsp;enableCors(res);<br><br>&nbsp;var address = req.params.address;<br><br>&nbsp;this.node.getAddressUnspentOutputs(address,
                                                                {}, function(err, unspentOutputs) {<br><br>&nbsp;&nbsp;if (err){<br><br>&nbsp;&nbsp;&nbsp;return self.log('err', err);<br><br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;self.log.info('Address data
                                                                (' + address + '):', unspentOutputs);<br><br>&nbsp;&nbsp;res.send(unspentOutputs);<br><br>&nbsp;});<br><br>}<br><br></p>
                                                                <p style="color: #2a2a2a;font-weight: normal;"><br><strong>Creating transactions</strong><br><br><br><br>To broadcast the transaction that includes the file hash, we need to add the following method to `<strong>index.js</strong>`:<br><br></p>
                                                                <p
                                                                    class="border rounded code" style="color: #eff1f4;background-color: #2a2a2a;padding-left: 15px;padding-right: 15px;font-weight: normal;"><br>StampingService.prototype.sendTransaction = function(req, res, next){<br><br>&nbsp;enableCors(res);<br><br>&nbsp;var self = this;<br><br>&nbsp;var serializedTransaction = req.params.transaction;<br><br><br><br>&nbsp;this.node.sendTransaction(serializedTransaction,
                                                                    function(err) {<br><br>&nbsp;&nbsp;if (err){<br><br>&nbsp;&nbsp;&nbsp;self.log('error sending transaction', err);<br><br>&nbsp;&nbsp;&nbsp;return res.send(500, err);<br><br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;res.sendStatus(200);<br><br>&nbsp;});<br><br>}<br><br></p>
                                                                    <p
                                                                        style="color: #2a2a2a;font-weight: normal;"><br><strong>Registering api endpoints</strong><br><br><br><br>In order for the client to query our custom ltzcore methods, we need to register those methods with ltzcore<br><br>by adding
                                                                        the following code to `<strong>index.js</strong>`:<br><br></p>
                                                                        <p class="border rounded code" style="color: #eff1f4;background-color: #2a2a2a;padding-left: 15px;padding-right: 15px;font-weight: normal;"><br>StampingService.prototype.setupRoutes = function(app) {<br><br>&nbsp;app.get('/hash/:hash', this.lookupHash.bind(this));<br><br>&nbsp;app.get('/address/:address', this.getAddressData.bind(this));<br><br>&nbsp;app.get('/send/:transaction',
                                                                            this.sendTransaction.bind(this));<br><br>}<br><br></p>
                                                                        <p style="color: #2a2a2a;font-weight: normal;"><br>Symlink your `<strong>stampingservice</strong>` into the node_modules directory of `<strong>mynode</strong>`:<br><br></p>
                                                                        <p class="border rounded code" style="color: #eff1f4;background-color: #2a2a2a;padding-left: 15px;padding-right: 15px;font-weight: normal;"><br>cd ~/i-made-this/mynode/node_modules<br><br>ln -s ~/i-made-this/stampingservice<br><br></p>
                                                                        <p style="color: #2a2a2a;font-weight: normal;"><br>And symlink the `<strong>ltzcore-lib</strong>` module, to a locally shared version for development:<br><br><br></p>
                                                                        <p class="text-nowrap border rounded code" style="overflow-x: scroll;color: #eff1f4;background-color: #2a2a2a;padding-left: 15px;padding-right: 15px;font-weight: normal;"><br>cd ~<br><br>git clone git@github.com/LitecoinZ-Community/ltzcore/tree/master/packages/ltzcore-lib.git<br><br>cd ltzcore-lib<br><br>npm install --production<br><br>cd ~/i-made-this/stampingservice/node_modules<br><br>ln
                                                                            -s ~/ltzcore-lib<br><br></p>
                                                                        <p style="color: #2a2a2a;font-weight: normal;"><br>Add `<strong>stampingservice</strong>` as a dependency in `<strong>mynode/ltzcore-node.json</strong>`:<br><br><br></p>
                                                                        <p class="border rounded code" style="color: #eff1f4;background-color: #2a2a2a;padding-left: 15px;padding-right: 15px;font-weight: normal;"><br>{<br><br>&nbsp;"network": "testnet",<br><br>&nbsp;"port": 3001,<br><br>&nbsp;"services": [<br><br>&nbsp;&nbsp;"litecoinzd",<br><br>&nbsp;&nbsp;"web",<br><br>&nbsp;&nbsp;"stampingservice"
                                                                            //add this<br><br>&nbsp;]<br><br>}<br><br></p>
                                                                        <p style="color: #2a2a2a;font-weight: normal;"><br><br>Restart your ltzcore node, and visit [http://localhost:3001/stampingservice/hash/aCrAzYHaSh](http://localhost:3001/stampingservice/hash/aCrAzYHaSh) in your browser. If all
                                                                            went well, the server response will be "Not Found", indicating that 'aCrAzYHaSh' has never been included in the blockchain.<br><br><br><br><strong>Wiring the client-side app to your ltzcore endpoints</strong><br><br><br><br>Since
                                                                            the focus of this tutorial is ltzcore, only ltzcore-specific client-side code<br><br>will be covered. The rest of the client code can be viewed in the [<a href="https://github.com/bitpay/i-made-this"><strong>project repository on GitHub</strong></a>]
                                                                            as reference.<br><br><br><br>To install the ltzcore client-side library, run:<br><br></p>
                                                                        <p class="border rounded code" style="color: #eff1f4;background-color: #2a2a2a;padding-left: 15px;padding-right: 15px;font-weight: normal;"><br>bower install ltzcore-lib --save<br><br></p>
                                                                        <p style="color: #2a2a2a;font-weight: normal;"><br>Include ltzcore in your `<strong>index.html</strong>` file via a script tag:<br><br></p>
                                                                        <p style="color: #fcfeff;background-color: #2a2a2a;padding-left: 15px;padding-right: 15px;padding-top: 15px;padding-bottom: 15px;font-weight: normal;">&lt;script src="bower_components/ltzcore-lib/ltzcore-lib.js"&gt;&lt;/script&gt;<br></p>
                                                                        <p style="color: #2a2a2a;font-weight: normal;"><br>Then require ltzcore globally via:<br><br></p>
                                                                        <p class="border rounded code" style="color: #eff1f4;background-color: #2a2a2a;padding-left: 15px;padding-right: 15px;font-weight: normal;"><br>ltzcore = require('ltzcore-lib');<br><br></p>
                                                                        <p style="color: #2a2a2a;font-weight: normal;"><br><strong>Hashing the uploaded file</strong><br><br><br><br>When a user uploads a file, we first need to hash the file client-side. This tutorial uses [<strong>ng-file-upload</strong>](https://github.com/danialfarid/ng-file-upload)'s<br><br>base64DataUrl
                                                                            to convert the file dataUrl to base64, which can then be used as an input to ltzcore's<br><br>Buffer class for hashing.<br><br></p>
                                                                        <p class="border rounded code" style="color: #eff1f4;background-color: #2a2a2a;padding-left: 15px;padding-right: 15px;font-weight: normal;"><br>function hashFile(file, cb){<br><br>&nbsp;Upload.base64DataUrl(file).then(function(urls){<br><br>&nbsp;&nbsp;var Buffer = ltzcore.deps.Buffer;<br><br>&nbsp;&nbsp;var data = new
                                                                            Buffer(urls, 'base64');<br><br>&nbsp;&nbsp;var hash = ltzcore.crypto.Hash.sha256sha256(data);<br><br>&nbsp;&nbsp;var hashString = hash.toString('hex');<br><br>&nbsp;&nbsp;return
                                                                            cb(hashString);<br><br>&nbsp;});<br><br>}<br><br></p>
                                                                        <p style="color: #2a2a2a;font-weight: normal;"><br>After hashing the file and converting to a hex string, we are ready<br><br>to query our ltzcore node to see if this file has already been stamped. In the code<br><br>below, we
                                                                            are sending a request to http://localhost:3001/stampingservice/hash/:fileHash,<br><br>which will trigger the lookupHash method we've configured on our ltzcore node:<br><br></p>
                                                                        <p
                                                                            class="border rounded code" style="color: #eff1f4;background-color: #2a2a2a;padding-left: 15px;padding-right: 15px;font-weight: normal;"><br>function isFileInBlockchain(fileHashString){<br><br>&nbsp;// Asks ltzcore-node if the hash of the uploaded file has been timestamped in<br><br>&nbsp;// the blockchain before<br><br>&nbsp;$http.get(ltzcoreServiceBasePath
                                                                            + '/hash/' + fileHashString)<br><br>&nbsp;&nbsp;.success(gotFile)<br><br><br><br>&nbsp;function gotFile(data, statusCode){<br><br>&nbsp;&nbsp;$scope.previousTimestamps = data;<br><br>&nbsp;&nbsp;$scope.previousTimestamps
                                                                            = $scope.previousTimestamps.map(function(ts){<br><br>&nbsp;&nbsp;&nbsp;// convert the integer timestamp to a date object for UI rendering<br><br>&nbsp;&nbsp;&nbsp;ts.date = new
                                                                            Date(ts.timestamp*1000);<br><br>&nbsp;&nbsp;&nbsp;return ts;<br><br>&nbsp;&nbsp;});<br><br>&nbsp;}<br><br><br><br>}<br><br></p>
                                                                            <p style="color: #2a2a2a;font-weight: normal;"><br>If the user chooses to timestamp the uploaded file, we'll need to generate<br><br>a new litecoinz address to which the user can send a small amount of litecoinz, which will
                                                                                be used to fund the timestamping<br><br>transaction. An address can be generated with the following code:<br><br><br></p>
                                                                            <p class="border rounded code" style="color: #eff1f4;background-color: #2a2a2a;padding-left: 15px;padding-right: 15px;font-weight: normal;"><br>privateKey = new ltzcore.PrivateKey();<br><br>var publicKey = new ltzcore.PublicKey(privateKey);<br><br>$scope.address = new ltzcore.Address(publicKey, ltzcore.Networks.testnet).toString();<br><br></p>
                                                                            <p
                                                                                style="color: #2a2a2a;font-weight: normal;"><br>We can be notified when the user has sent funds to this address by polling<br><br>our ltzcore node via the [http://localhost:3001/stampingservice/address/:address]<br><br>endpoint:<br><br></p>
                                                                                <p
                                                                                    class="border rounded code" style="color: #eff1f4;background-color: #2a2a2a;padding-left: 15px;padding-right: 15px;font-weight: normal;"><br>function montiorAddress(address, cb){<br><br>&nbsp;// Asks ltzcore-node whether the input LTZ address has received funds from the user<br><br>&nbsp;function gotAddressInfo(data,
                                                                                    statusCode){<br><br>&nbsp;&nbsp;if(data.length){<br><br>&nbsp;&nbsp;&nbsp;var unspentOutput = data[0];<br><br>&nbsp;&nbsp;&nbsp;$interval.cancel(pollInterval);<br><br>&nbsp;&nbsp;&nbsp;cb(unspentOutput);<br><br>&nbsp;&nbsp;}<br><br>&nbsp;}<br><br><br><br>&nbsp;pollInterval
                                                                                    = $interval(function(){<br><br>&nbsp;&nbsp;console.log('montiorAddress interval called for address:', address);<br><br>&nbsp;&nbsp;$http.get(ltzcoreServiceBasePath + '/address/'
                                                                                    + address)<br><br>&nbsp;&nbsp;&nbsp;.success(gotAddressInfo)<br><br>&nbsp;}, 1000); // poll every second<br><br>}<br><br></p>
                                                                                    <p style="color: #2a2a2a;font-weight: normal;"><br>Once the user's LTZ arrives at the generated address, we can now create a new transaction<br><br>to which we will attach the hash of the uploaded file.<br><br></p>
                                                                                    <p
                                                                                        class="border rounded code" style="color: #eff1f4;background-color: #2a2a2a;padding-left: 15px;padding-right: 15px;font-weight: normal;"><br>function timeStampFile(unspentOutput, privateKey){<br><br>&nbsp;// Uses the LTZ received from the user to create a new transaction object<br><br>&nbsp;// that includes
                                                                                        the hash of the uploaded file<br><br>&nbsp;var UnspentOutput = ltzcore.Transaction.UnspentOutput;<br><br>&nbsp;var Transaction = ltzcore.Transaction;<br><br>&nbsp;var
                                                                                        unspent2 = UnspentOutput(unspentOutput);<br><br><br><br>&nbsp;// Let's create a transaction that sends all recieved LTZ to a miner<br><br>&nbsp;// (no coins will go
                                                                                        to a change address)<br><br>&nbsp;var transaction2 = Transaction();<br><br>&nbsp;transaction2<br><br>&nbsp;&nbsp;.from(unspent2)<br><br>&nbsp;&nbsp;.fee(50000);<br><br><br><br>&nbsp;//
                                                                                        Append the hash of the file to the transaction<br><br>&nbsp;transaction2.addOutput(new Transaction.Output({<br><br>&nbsp;&nbsp;script: ltzcore.Script.buildDataOut(fileHash,
                                                                                        'hex'),<br><br>&nbsp;&nbsp;satoshis: 0<br><br>&nbsp;}));<br><br><br><br>&nbsp;// Sign transaction with the original private key that generated<br><br>&nbsp;// the
                                                                                        address to which the user sent LTZ<br><br>&nbsp;transaction2.sign(privateKey);<br><br>&nbsp;$scope.transactionId = transaction2.id;<br><br>&nbsp;var serializedTransaction
                                                                                        = transaction2.checkedSerialize();<br><br><br><br>&nbsp;sendTransaction(serializedTransaction);<br><br>}<br><br><br><br>function sendTransaction(serializedTransaction){<br><br>&nbsp;//
                                                                                        Asks ltzcore-node to broadcast the timestamped transaction<br><br>&nbsp;$http.get(ltzcoreServiceBasePath + '/send/' + serializedTransaction)<br><br>&nbsp;&nbsp;.success(sentTransaction);<br><br><br><br>&nbsp;function
                                                                                        sentTransaction(){<br><br>&nbsp;&nbsp;$scope.stampSuccess = true;<br><br>&nbsp;&nbsp;pendingFileHashes[fileHash] = {date: new Date()};<br><br>&nbsp;}<br><br>}<br><br></p>
                                                                                        <p
                                                                                            class="text-break text-left" style="color: #2a2a2a;font-weight: normal;"><br><br><strong>The End</strong><br><br>That's it! Have questions about this tutorial? [<a href="https://github.com/LitecoinZ-Community/ltzcore"><strong>Post them here</strong></a>].<br><br>You
                                                                                            can also [<a href="https://github.com/bitpay/i-made-this"><strong>view the completed project files on GitHub</strong></a>] as reference.<br></p>
                </div>
            </div>
        </div>
    </div>
    <div class="footer-clean" style="color: #eaf4f8;background-color: #333333;">
        <footer>
            <div class="container">
                <div class="row justify-content-center">
                    <div class="col-sm-4 col-md-3 item">
                        <h3>LitecoinZ</h3>
                        <ul>
                            <li><a href="https://blog.litecoinz.org">Blog</a></li>
                            <li><a href="../index.html">LitecoinZ</a></li>
                            <li><a href="../roadmap.html">Roadmap</a></li>
                            <li><a href="https://litecoinz.org/downloads/LITECOINZ-WHITE-PAPER.pdf">White Paper</a></li>
                        </ul>
                    </div>
                    <div class="col-sm-4 col-md-3 item">
                        <h3>Github</h3>
                        <ul>
                            <li><a href="https://github.com/litecoinz-project">Project</a></li>
                            <li><a href="https://github.com/LitecoinZ-Community">Community</a></li>
                        </ul>
                    </div>
                    <div class="col-sm-4 col-md-3 item">
                        <ul></ul>
                    </div>
                    <div class="col-lg-3 item social"><a href="https://discord.gg/QNcS4Pm"><i class="fab fa-discord"></i></a><a href="https://www.facebook.com/LitecoinZOfficialPage"><i class="icon ion-social-facebook"></i></a><a href="https://twitter.com/LitecoinzTeam"><i class="icon ion-social-twitter"></i></a>
                        <a
                            href="https://bitcointalk.org/index.php?topic=2767102.0"><i class="icon ion-social-bitcoin"></i></a>
                            <p class="copyright" style="color: #eaf4f8;">LitecoinZ Developers &nbsp;2019</p>
                    </div>
                </div>
            </div>
        </footer>
    </div>
    <div style="visibility: hidden;/*z-index: 1000;*//*opacity: 0;*/"><script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script><div id="particles-js"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/aos/2.1.1/aos.js"></script>
    <script src="../assets/js/script.min.js"></script>
</body>

</html>